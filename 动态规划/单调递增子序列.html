<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>最长递增子序列</title>


</head>
<body>
    
</body>

<script type="text/javascript">
/*

给定一个长度为N的数组，找出一个最长的单调递增子序列，子序列不一定连续，但初始顺序不能乱。

例如：给定一个长度为6的数组A{4， 5， 7， 1，3， 9}，则其最长的单调递增子序列为{4，5，7，9}，长度为4。

动态规划思路：

记d[i]为以任意一个A[i]为末尾元素组成的最长递增子序列的长度，找出所有位于i之前且比A[i]小的元素A[j]，此时可

出现两种情况：

（1）若找到，例如i = 2，此时A[i] = 7，比A[i]小的元素为A[0] = 4，A[1] = 5，取所有比A[i]小的元素中A[j]中，对应的d[j]最

大的加1，即d[i] = max{ d[j] }+1，其中j < i 且 A[j] < A[i]；

（2）若没有找到，例如i = 3，此时A[i] = 1，i之前不存在比1小的元素，此时A[3] = 1独自构成一个递增子序列，d[i] = 1。

实现过程：

*/

var arr = [10,9,2,5,3,7,101,18]

function subsequentIncreasing(arr){
	let n = arr.length;
	let dp = new Array(n).fill(1); //肯定都是1
	for(let i=0;i<n;i++){
		for(let j=0;j<i;j++){
			if(arr[j]<arr[i]&&dp[j]>=(dp[i])){
				dp[i] = dp[j]+1;
			}

		}
	}

	return Math.max(...dp)
}

console.log(subsequentIncreasing(arr))


</script>
</html>